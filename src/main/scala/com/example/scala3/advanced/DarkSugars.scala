package com.example.scala3.advanced

object SingleAbstractMethodPattern extends App {

  trait MyTrait {
    def doSomething(s: String): Unit
  }

  val mySomething: MyTrait = (s: String) => println(s)

  mySomething.doSomething("Hello")

}

object RightAssociativeExpressions extends App {

  // THe ones finishing wiht a ":" (like Scala Lists' :: operator)
  val myList = 0 :: 2 :: 3 :: List(1, 2, 4)

  // Also custom defined
  class MyStream[T] {
    infix def -->:(value: T): MyStream[T] = ???
  }

  val myStream = 1 -->: 2 -->: 3 -->: new MyStream[Int]

}

object InfixTypes extends App {
  import scala.annotation.targetName
  @targetName(
    "Arrow"
  ) // This will help to make generated bytecode more readable (in case you want to work with bytecode), and Java interop (Java can't do infix as Scala does)
  infix class -->[A, B]

  val compositeType: -->[Int, String] = new -->
  // or
  val compositeType_v2: Int --> String = new -->
}

object MultiWordIdentifiers extends App {

  object `Content-Type`:
    val `application-json` = "application/json"

  val format = `Content-Type`.`application-json`
}

object UpdateMutableCollections extends App {
  // Mutable operations for collections
  val myArray = Array(1, 2, 3, 4, 5) // This is using java.util.Array

  myArray.update(2, 45) // this will replace 3 with 45
  // or
  myArray(2) = 45 // Same syntax as in Java!
}

object VarArgs extends App {
  def myMethod(i: Int*): Unit = println(i)

  val myList = List(1, 2, 3, 4)
  myMethod(myList*) // This will unwrap mylist into the varargs
}